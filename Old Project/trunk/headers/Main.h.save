#ifndef MAIN_H_INCLUDED
#define MAIN_H_INCLUDED

#define sqr(a) ((a)*(a))

// точность до
const double Eps = 1e-5;
const double Sur = 1e-5;

typedef double type;

// направление
struct Direction {
    type dx;
    type dy;

    Direction () {} ;
    Direction (type ax, type ay) : dx(ax), dy(ay) {} ;
};

// точка
struct Point {
    type x;
    type y;
    Point() {};
    Point( type ax, type ay) : x(ax), y(ay) {} ;

    bool normalize() {
        type cf = sqrtf(x*x + y*y);
        if (cf < Eps) return false;
        cf = 1.0f / cf;
        x *= cf;
        y *= cf;
        return true;
    }

	Point & operator += (const Point& other) {
		x += other.x; y += other.y;
		return *this;
	}
	Point & operator -= (const Point& other) {
		x -= other.x; y -= other.y;
		return *this;
	}

	const Point operator + (const Point& other) const {
		return Point(x + other.x, y + other.y);
	}
	const Point operator - (const Point& other) const {
		return Point(x - other.x, y - other.y);
	}
	const Point operator * (const type other) const {
		return Point(x * other, y * other);
	}
	const Point operator / (const type other) const {
		return Point(x / other, y / other);
	}
};

// Прямая
class Line
{
public:
    double a, b, c;
    // Создание прямой ax + by + c = 0
    Line(double _a = 0, double _b = 0, double _c = 0)
    {
        a = _a;
        b = _b;
        c = _c;
    }
};

// абсолютное значение
type abs(type a);

// начальная скорость
const type Speed0 = 1.0;

// пересечение отрезков
bool intersect(Point a, Point b, Point c, Point d);

// точка пересечения
bool cross_segment (Point p1, Point p2, Point p3, Point p4, Point &t);

// вспомогательное
int area(Point a, Point b, Point c);
bool intersect_1(int a, int b, int c, int d);

#endif // MAIN_H_INCLUDED
